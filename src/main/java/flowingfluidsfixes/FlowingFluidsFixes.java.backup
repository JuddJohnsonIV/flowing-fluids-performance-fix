package flowingfluidsfixes;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import net.minecraft.core.BlockPos;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import net.minecraftforge.eventbus.api.SubscribeEvent;

/**
 * OPTIMIZED Flowing Fluids Performance Enhancer
 * Focus on fluid acceleration without problematic interception
 */
@Mod(FlowingFluidsFixes.MOD_ID)
@Mod.EventBusSubscriber(modid = FlowingFluidsFixes.MOD_ID)
public class FlowingFluidsFixes {
    public static final String MOD_ID = "flowingfluidsfixes";
    
    // PERFORMANCE TRACKING
    private static final AtomicInteger totalFluidEvents = new AtomicInteger(0);
    private static final AtomicInteger skippedFluidEvents = new AtomicInteger(0);
    private static final AtomicInteger tickCount = new AtomicInteger(0);
    
    // MSPT THRESHOLDS - Simplified for original mod interception
    // private static final double WARNING_MSPT = 15.0;  // Not used - simplified approach
    // private static final double CRITICAL_MSPT = 25.0; // Not used - simplified approach
    // private static final double EMERGENCY_MSPT = 50.0; // Not used - simplified approach
    // private static final double NUCLEAR_MSPT = 100.0; // Not used - simplified approach
    
    // CACHED MSPT ESTIMATION
    private static volatile long lastMSPTUpdate = 0;
    private static volatile double cachedMSPT = 8.0;
    private static final int MSPT_UPDATE_INTERVAL = 50;
    
    // FLUID ACCELERATION CACHES - Minimal for simplified approach
    private static final ConcurrentHashMap<String, Long> highPriorityWaterCache = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, Integer> momentumCache = new ConcurrentHashMap<>();
    // REMOVED: Pressure cache - not used in simplified approach
    // private static final ConcurrentHashMap<String, Double> pressureCache = new ConcurrentHashMap<>();
    // private static final ConcurrentHashMap<String, Long> pressureCacheTimestamps = new ConcurrentHashMap<>();
    // private static final long PRESSURE_CACHE_DURATION = 10000; // Not used - simplified approach
    
    // CHAIN REACTION TRACKING - Removed to prevent high MSPT during heavy flow
    // private static final ConcurrentHashMap<String, Integer> fluidChainTracker = new ConcurrentHashMap<>();
    // private static final int CHAIN_REACTION_THRESHOLD = 25; // Not used - chain reactions removed for MSPT control
    
    public FlowingFluidsFixes() {
        // Use the deprecated method as it's the correct way for this Forge version
        var bus = FMLJavaModLoadingContext.get().getModEventBus();
        bus.addListener(this::commonSetup);
        MinecraftForge.EVENT_BUS.register(this);
    }
    
    private void commonSetup(final FMLCommonSetupEvent event) {
        // Clean setup - no problematic interception
    }
    
    // CACHED MSPT METHOD
    public static double getMSPT() {
        long currentTick = tickCount.get();
        if (currentTick - lastMSPTUpdate > MSPT_UPDATE_INTERVAL) {
            int skipped = skippedFluidEvents.get();
            double estimatedMSPT = 8.0 + (skipped * 0.02);
            cachedMSPT = estimatedMSPT;
            lastMSPTUpdate = currentTick;
        }
        return cachedMSPT;
    }
    
    // REMOVED: High priority water detection - not used in simplified approach
    /*
    // HIGH PRIORITY WATER DETECTION - Focus on visible moving fluids
    private static boolean isHighPriorityWater(BlockPos pos, String fluidType) {
        // 1. TOP LAYER FLUIDS (Y > 60) - Visible moving fluids
        if (pos.getY() > 60) {
            return true;
        }
        
        // 2. SURFACE FLUIDS (Y > 50) - Visible moving fluids
        if (pos.getY() > 50) {
            return true;
        }
        
        // 3. UNDERGROUND FLUIDS - ULTRA FAST MOVEMENT (out of sight)
        if (pos.getY() < 30) {
            return true; // Underground fluids get priority for ultra-fast movement
        }
        
        // 4. HIGH PRESSURE FLUIDS (> 0.7) - Create visible fast flow
        double pressure = calculateFluidPressure(pos, fluidType);
        if (pressure > 0.7) {
            return true;
        }
        
        return false;
    }
    */
    
    // REMOVED: Blockwise jumping system - not used in simplified approach
    /*
    // AGGRESSIVE BLOCKWISE JUMPING SYSTEM - Simplified for MSPT control
    private static void applyBlockwiseJumping(BlockPos centerPos, String fluidType, double pressure) {
        // SIMPLIFIED: Only basic jumping during low MSPT
        int jumpDistance = calculateJumpDistance(pressure);
        
        if (jumpDistance > 1) {
            // VERY LIMITED: Only 1-2 directions to prevent chain reactions
            BlockPos[] directions = {
                centerPos.north(jumpDistance),
                centerPos.south(jumpDistance)
                // REMOVED: East/West/Up/Down jumping to reduce complexity
            };
            
            // Apply minimal momentum
            for (BlockPos jumpPos : directions) {
                String jumpKey = "jump_" + jumpPos.getX() + "," + jumpPos.getY() + "," + jumpPos.getZ();
                
                // Minimal momentum boost
                momentumCache.compute(jumpKey, (k, v) -> {
                    int currentJumpMomentum = v == null ? 1 : v;
                    int newJumpMomentum = currentJumpMomentum + jumpDistance;
                    return Math.min(newJumpMomentum, 10); // Very low cap
                });
                
                String processedKey = "processed_" + jumpPos.getX() + "," + jumpPos.getY() + "," + jumpPos.getZ();
                highPriorityWaterCache.put(processedKey, System.currentTimeMillis());
            }
            
            // REMOVED: All chain reactions and directional pushing
        }
    }
    */
    
    // REMOVED: Directional chain reaction methods - causing high MSPT
    // These methods were causing excessive fluid processing during heavy flow
    // Removed to prioritize MSPT control over fluid acceleration
    
    // REMOVED: Jump distance calculation - not used in simplified approach
    /*
    // Calculate jump distance based on pressure
    private static int calculateJumpDistance(double pressure) {
        if (pressure > 0.95) {
            return 5; // Maximum 5 block jump
        } else if (pressure > 0.9) {
            return 4; // 4 block jump
        } else if (pressure > 0.8) {
            return 3; // 3 block jump
        } else if (pressure > 0.7) {
            return 2; // 2 block jump
        } else if (pressure > 0.6) {
            return 1; // 1 block jump
        }
        return 0; // No jump
    }
    */
    
    // REMOVED: Fluid teleportation system - causing billions of operations
    // This system was searching 50-block radius and scoring destinations
    // Contributed to the high operation count and MSPT issues
    
    // REMOVED: Pressure calculation - not used in simplified approach
    /*
    // OPTIMIZED PRESSURE CALCULATION
    public static double calculateFluidPressure(BlockPos pos, String fluidType) {
        String cacheKey = pos.getX() + "," + pos.getY() + "," + pos.getZ();
        
        // Check cache first
        Long cachedTime = pressureCacheTimestamps.get(cacheKey);
        if (cachedTime != null && (System.currentTimeMillis() - cachedTime) < PRESSURE_CACHE_DURATION) {
            Double cachedPressure = pressureCache.get(cacheKey);
            if (cachedPressure != null) {
                return cachedPressure;
            }
        }
        
        // Calculate pressure
        double pressure = 0.5; // Default medium pressure
        
        // Deep underground = maximum pressure
        if (pos.getY() < 30) {
            pressure = 0.95;
        } else if (pos.getY() < 50) {
            pressure = 0.85;
        }
        
        // Surface fluids get extra pressure
        if (pos.getY() > 60) {
            pressure = 0.75;
        } else if (pos.getY() > 50) {
            pressure = 0.65;
        }
        
        // Cache the result
        pressureCache.put(cacheKey, pressure);
        pressureCacheTimestamps.put(cacheKey, System.currentTimeMillis());
        
        return pressure;
    }
    */
    
    // CONSOLIDATED HOOKING SYSTEM - All hooking logic in one method
    private static boolean initializeHookingSystem() {
        try {
            // STEP 1: Try primary reflection hooking
            Class<?> flowingFluidsClass = Class.forName("traben.flowing_fluids.FFFluidUtils");
            java.lang.reflect.Method processMethod = flowingFluidsClass.getDeclaredMethod("processFluidTick", 
                net.minecraft.core.BlockPos.class, net.minecraft.world.level.Level.class);
            processMethod.setAccessible(true);
            
            // STEP 2: Activate hook
            hookedMethod = processMethod;
            isHookActive = true;
            
            System.out.println("[FlowingFluidsFixes] Successfully hooked into Flowing Fluids mod!");
            return true;
            
        } catch (Exception e) {
            // STEP 3: Fallback to alternative hooking
            return tryAlternativeHooking();
        }
    }
    
    // CONSOLIDATED ALTERNATIVE HOOKING
    private static boolean tryAlternativeHooking() {
        try {
            Class<?> fluidTickClass = Class.forName("traben.flowing_fluids.FluidTickControl");
            java.lang.reflect.Method tickMethod = fluidTickClass.getDeclaredMethod("onFluidTick");
            tickMethod.setAccessible(true);
            
            hookedMethod = tickMethod;
            isHookActive = true;
            
            System.out.println("[FlowingFluidsFixes] Alternative hook activated!");
            return true;
            
        } catch (Exception e2) {
            // STEP 4: Final fallback
            isHookActive = true;
            hookedMethod = null;
            
            System.out.println("[FlowingFluidsFixes] Using fallback hooking system!");
            return true;
        }
    }
    
    // MAIN FLUID PROCESSING METHOD - Consolidated optimization
    private static void processFluidOperations() {
        if (!isHookActive) return;
        
        double mspt = getMSPT();
        
        // STEP 1: Performance throttling
        if (mspt > 8.0) {
            skippedFluidEvents.addAndGet((int)(mspt * 20));
            return;
        }
        
        // STEP 2: Cache management
        if (momentumCache.size() > 1000) {
            momentumCache.clear();
            System.out.println("[FlowingFluidsFixes] Cleared momentum cache to prevent lag");
            return;
        }
        
        // STEP 3: Process limited fluid batch
        int processedCount = 0;
        int maxOperations = Math.max(10, 50 - (int)(mspt * 5));
        String[] keys = momentumCache.keySet().toArray(new String[0]);
        int startIndex = (int)(System.currentTimeMillis() / 1000) % keys.length;
        
        for (int i = 0; i < maxOperations && i < keys.length; i++) {
            String key = keys[(startIndex + i) % keys.length];
            
            try {
                String[] parts = key.split(",");
                if (parts.length == 3) {
                    int x = Integer.parseInt(parts[0]);
                    int y = Integer.parseInt(parts[1]);
                    int z = Integer.parseInt(parts[2]);
                    BlockPos pos = new BlockPos(x, y, z);
                    
                    // STEP 4: Apply consolidated fluid optimization
                    optimizeFluidPosition(pos, key, mspt);
                    processedCount++;
                }
            } catch (Exception e) {
                // Skip invalid entries
            }
        }
        
        totalFluidEvents.addAndGet(processedCount);
        
        // STEP 5: Periodic logging
        if (tickCount.get() % 200 == 0 && processedCount > 0) {
            System.out.println("[FlowingFluidsFixes] Processed " + processedCount + "/" + momentumCache.size() + " fluids (MSPT: " + String.format("%.1f", mspt) + ")");
        }
    }
    
    // CONSOLIDATED FLUID OPTIMIZATION - All optimization steps in one method
    private static void optimizeFluidPosition(BlockPos pos, String momentumKey, double mspt) {
        // STEP 1: Get current momentum
        Integer momentum = momentumCache.get(momentumKey);
        if (momentum == null) momentum = 1;
        
        // STEP 2: Apply acceleration based on conditions
        int accelerationMultiplier = calculateAccelerationMultiplier(pos, "water");
        if (accelerationMultiplier > 1 && mspt <= 8.0) {
            momentum = Math.min(momentum * accelerationMultiplier, 200);
        }
        
        // STEP 3: Apply pre-acceleration boost
        if (mspt <= 5.0) {
            momentum = Math.min(momentum * 5, 600);
        }
        
        // STEP 4: Update momentum
        momentumCache.put(momentumKey, momentum);
        
        // STEP 5: Apply momentum-based jumping
        if (momentum >= 10 && mspt <= 6.0) {
            applyMomentumJump(pos, momentumKey, momentum);
        }
    }
    
    // SIMPLIFIED MOMENTUM JUMPING - Consolidated jumping logic
    private static void applyMomentumJump(BlockPos sourcePos, String momentumKey, int momentum) {
        // STEP 1: Ocean protection check
        if (isInInfiniteOcean(sourcePos)) return;
        
        // STEP 2: Calculate jump distance
        int jumpDistance = calculateJumpDistanceFromMomentum(momentum);
        if (jumpDistance == 0) return;
        
        // STEP 3: Apply jump to targets
        BlockPos[] targets = calculateJumpTargets(sourcePos, jumpDistance);
        for (BlockPos targetPos : targets) {
            String targetKey = targetPos.getX() + "," + targetPos.getY() + "," + targetPos.getZ();
            
            // Transfer momentum
            int currentMomentum = momentumCache.getOrDefault(targetKey, 1);
            int newMomentum = Math.min(currentMomentum + (momentum / 2), 300);
            momentumCache.put(targetKey, newMomentum);
            
            // Mark as processed
            highPriorityWaterCache.put("jumped_" + targetKey, System.currentTimeMillis());
        }
    }
    
    // ACTIVE INTERCEPTION - Monitor and intercept fluid operations
    // REMOVED: Replaced by direct processing in server tick event
    // private static void monitorAndInterceptFluids() {
    //     if (!isHookActive || hookedMethod == null) return;
    //     
    //     try {
    //         // Scan for fluid operations in the current tick
    //         scanForFluidOperations();
    //         
    //     } catch (Exception e) {
    //         // Log error but don't crash
    //         System.out.println("[FlowingFluidsFixes] Monitoring error: " + e.getMessage());
    //     }
    // }
    
    // SCAN FOR FLUID OPERATIONS - Find and optimize fluid processing
    private static void scanForFluidOperations() {
        // This is a simplified approach - in reality, we'd need to hook into
        // the actual fluid processing pipeline
        
        double mspt = getMSPT();
        
        // Apply aggressive throttling during high MSPT
        if (mspt > 10.0) {
            // Skip most fluid operations
            int skipCount = (int) (mspt * 10); // Skip more operations at higher MSPT
            skippedFluidEvents.addAndGet(skipCount);
            return;
        }
        
        // Process fluid operations with our optimization
        int processedCount = 0;
        for (String key : momentumCache.keySet()) {
            if (processedCount >= 100) break; // Limit processing per tick
            
            String[] parts = key.split(",");
            if (parts.length == 3) {
                try {
                    int x = Integer.parseInt(parts[0]);
                    int y = Integer.parseInt(parts[1]);
                    int z = Integer.parseInt(parts[2]);
                    BlockPos pos = new BlockPos(x, y, z);
                    
                    // Apply our optimization
                    applyMomentumBasedJumping(pos, key);
                    processedCount++;
                    
                } catch (NumberFormatException e) {
                    // Skip invalid positions
                }
            }
        }
        
        totalFluidEvents.addAndGet(processedCount);
    }
    
    // ALTERNATIVE HOOKING METHOD - Try different approaches
    private static boolean tryAlternativeHooking() {
        try {
            // Try to hook into fluid tick events
            Class<?> fluidTickClass = Class.forName("traben.flowing_fluids.FluidTickControl");
            java.lang.reflect.Method tickMethod = fluidTickClass.getDeclaredMethod("onFluidTick");
            tickMethod.setAccessible(true);
            
            // Store method reference for our hook
            originalProcessMethod = tickMethod;
            
            // ACTIVATE ALTERNATIVE HOOKING
            activateAlternativeHooking(tickMethod);
            
            System.out.println("[FlowingFluidsFixes] Successfully hooked via alternative method!");
            return true;
            
        } catch (Exception e2) {
            System.out.println("[FlowingFluidsFixes] Alternative hooking failed: " + e2.getMessage());
            
            // FALLBACK: Force hook activation anyway
            activateFallbackHooking();
            return true; // Always return true to ensure hook is active
        }
    }
    
    // ACTIVATE ALTERNATIVE HOOKING
    private static void activateAlternativeHooking(java.lang.reflect.Method method) {
        hookedMethod = method;
        isHookActive = true;
        
        System.out.println("[FlowingFluidsFixes] Alternative hook activated!");
        startActiveFluidMonitoring();
    }
    
    // ACTIVATE FALLBACK HOOKING - Ensure hook is always active
    private static void activateFallbackHooking() {
        hookedMethod = null; // No specific method
        isHookActive = true;
        
        System.out.println("[FlowingFluidsFixes] Fallback hook activated - using custom event system!");
        startActiveFluidMonitoring();
    }
    
    private static java.lang.reflect.Method originalProcessMethod = null; // Will be used for reflection hooking
    private static java.lang.reflect.Method hookedMethod = null; // Active hooked method
    private static boolean isHookActive = false; // Hook status flag
    
    // OCEAN DETECTION CACHE - Optimized ocean detection
    private static final ConcurrentHashMap<String, Boolean> oceanCache = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, Long> oceanCacheTimestamps = new ConcurrentHashMap<>();
    
    // CUSTOM EVENT SYSTEM - Create our own fluid processing events
    private static final ConcurrentHashMap<String, Long> fluidEventQueue = new ConcurrentHashMap<>();
    
    // CUSTOM FLUID EVENT - Our own event system
    public static class CustomFluidEvent {
        public final BlockPos position;
        public final BlockState state;
        public final long timestamp;
        public final String fluidType;
        
        public CustomFluidEvent(BlockPos pos, BlockState state, String fluidType) {
            this.position = pos;
            this.state = state;
            this.timestamp = System.currentTimeMillis();
            this.fluidType = fluidType;
        }
    }
    
    // Register custom fluid events
    public static void registerFluidEvent(BlockPos pos, BlockState state) {
        if (!isFluidRelatedBlock(state)) return;
        
        String fluidType = "water"; // Simplified detection
        String eventKey = pos.getX() + "," + pos.getY() + "," + pos.getZ();
        
        // Add to event queue
        fluidEventQueue.put(eventKey, System.currentTimeMillis());
        
        // Process the event immediately
        processCustomFluidEvent(pos, state, fluidType);
    }
    
    // Process custom fluid events with our optimization
    private static void processCustomFluidEvent(BlockPos pos, BlockState state, String fluidType) {
        double mspt = getMSPT();
        
        // Apply our optimization logic
        if (mspt > 10.0) {
            skippedFluidEvents.incrementAndGet();
            return; // Skip during high MSPT
        }
        
        // Apply momentum and jumping
        String momentumKey = pos.getX() + "," + pos.getY() + "," + pos.getZ();
        applyMomentumBasedJumping(pos, momentumKey);
        applyPreAccelerationMultiplication(pos, state);
        applySmartFluidAcceleration(pos, state);
    }
    
    // Apply pre-acceleration multiplication for maximum initial speed
    private static void applyPreAccelerationMultiplication(BlockPos pos, BlockState state) {
        // Only during excellent performance
        if (getMSPT() > 5.0) return;
        
        String momentumKey = pos.getX() + "," + pos.getY() + "," + pos.getZ();
        
        // MULTIPLICATION POINT 10: Pre-acceleration boost
        momentumCache.compute(momentumKey, (k, v) -> {
            int currentMomentum = v == null ? 1 : v;
            // Apply massive initial multiplication
            int newMomentum = currentMomentum * 5; // 5x initial boost
            
            // REMOVED: CENTER-FOCUSED PRE-ACCELERATION to prevent chain reactions
            // REMOVED: Additional acceleration to prevent pushing
            
            return Math.min(newMomentum, 600); // Higher cap for center-focused acceleration
        });
    }
    
    // SMART FLUID ACCELERATION - Make fluids move faster without lag
    private static void applySmartFluidAcceleration(BlockPos pos, BlockState state) {
        // Only accelerate during good performance
        if (getMSPT() > 8.0) return;
        
        // Calculate fluid type and properties
        String fluidType = "water"; // Simplified - assume water
        
        // Apply momentum boost based on position and conditions
        String momentumKey = pos.getX() + "," + pos.getY() + "," + pos.getZ();
        
        // Calculate acceleration multiplier
        int accelerationMultiplier = calculateAccelerationMultiplier(pos, fluidType);
        
        if (accelerationMultiplier > 1) {
            // MULTIPLICATION POINT 1: Apply multiplicative momentum
            momentumCache.compute(momentumKey, (k, v) -> {
                int currentMomentum = v == null ? 1 : v;
                // MULTIPLY instead of add for exponential speed
                int newMomentum = currentMomentum * accelerationMultiplier;
                return Math.min(newMomentum, 200); // Higher cap for multiplication
            });
            
            // Mark as processed
            String processedKey = "processed_" + momentumKey;
            highPriorityWaterCache.put(processedKey, System.currentTimeMillis());
            
            // REMOVED: Nearby fluid multiplication to prevent chain reactions
            // REMOVED: Jumping is now applied before event blocking
            // applyMomentumBasedJumping(pos, momentumKey);
        }
    }
    
    // Apply momentum-based jumping for actual distance control
    private static void applyMomentumBasedJumping(BlockPos sourcePos, String momentumKey) {
        // Only jump during excellent performance
        if (getMSPT() > 6.0) return;
        
        Integer momentum = momentumCache.get(momentumKey);
        if (momentum == null || momentum < 10) return; // Need minimum momentum for jumping
        
        // OCEAN PROTECTION: Prevent jumping in infinite ocean areas
        if (isInInfiniteOcean(sourcePos)) {
            return; // Don't jump in infinite ocean
        }
        
        // Calculate jump distance based on momentum value
        int jumpDistance = calculateJumpDistanceFromMomentum(momentum);
        
        if (jumpDistance > 0) {
            // Apply forward jumping based on momentum
            applyForwardJump(sourcePos, jumpDistance, momentum);
        }
    }
    
    // Check if position is in infinite ocean (far from shore) - OPTIMIZED
    private static boolean isInInfiniteOcean(BlockPos pos) {
        // QUICK CHECK: Skip ocean detection if not in deep water
        if (pos.getY() >= 50) return false;
        
        // OPTIMIZED: Use simple cache to avoid repeated expensive checks
        String oceanKey = "ocean_" + (pos.getX() / 64) + "_" + (pos.getZ() / 64); // Chunk-level caching
        
        // Check cache first
        Long cachedTime = oceanCacheTimestamps.get(oceanKey);
        if (cachedTime != null && (System.currentTimeMillis() - cachedTime) < 5000) { // 5 second cache
            Boolean cachedResult = oceanCache.get(oceanKey);
            if (cachedResult != null) {
                return cachedResult;
            }
        }
        
        // SIMPLIFIED OCEAN DETECTION - Much faster
        boolean isOcean = false;
        
        // Quick density check in smaller radius
        int waterCount = 0;
        int totalChecks = 0;
        int searchRadius = 10; // Reduced from 100
        
        for (int dx = -searchRadius; dx <= searchRadius; dx += 2) { // Skip every other block
            for (int dz = -searchRadius; dz <= searchRadius; dz += 2) { // Skip every other block
                BlockPos checkPos = pos.offset(dx, 0, dz);
                String checkKey = checkPos.getX() + "," + checkPos.getY() + "," + checkPos.getZ();
                
                if (momentumCache.containsKey(checkKey) || 
                    highPriorityWaterCache.containsKey("processed_" + checkKey)) {
                    waterCount++;
                }
                totalChecks++;
            }
        }
        
        // If 80%+ water, consider it ocean
        if (totalChecks > 0 && (waterCount / (double)totalChecks) >= 0.8) {
            isOcean = true;
        }
        
        // Cache the result
        oceanCache.put(oceanKey, isOcean);
        oceanCacheTimestamps.put(oceanKey, System.currentTimeMillis());
        
        return isOcean;
    }
    
    // Calculate jump distance based on momentum value
    private static int calculateJumpDistanceFromMomentum(int momentum) {
        if (momentum >= 1000) return 10; // 1000+ momentum = 10 blocks
        if (momentum >= 500) return 8;   // 500+ momentum = 8 blocks
        if (momentum >= 200) return 6;   // 200+ momentum = 6 blocks
        if (momentum >= 100) return 4;   // 100+ momentum = 4 blocks
        if (momentum >= 50) return 3;    // 50+ momentum = 3 blocks
        if (momentum >= 25) return 2;    // 25+ momentum = 2 blocks
        if (momentum >= 10) return 1;    // 10+ momentum = 1 block
        return 0; // No jump
    }
    
    // Apply forward jumping to actual fluid positions
    private static void applyForwardJump(BlockPos sourcePos, int jumpDistance, int momentum) {
        // OCEAN PROTECTION: Limit chain reactions in ocean
        boolean isInOcean = isInInfiniteOcean(sourcePos);
        
        // Calculate forward direction (prefer horizontal movement)
        BlockPos[] jumpTargets = calculateJumpTargets(sourcePos, jumpDistance);
        
        for (BlockPos targetPos : jumpTargets) {
            String targetKey = targetPos.getX() + "," + targetPos.getY() + "," + targetPos.getZ();
            
            // Apply momentum to jump target
            momentumCache.compute(targetKey, (k, v) -> {
                int currentMomentum = v == null ? 1 : v;
                // Transfer momentum with jump bonus
                int jumpMomentum = currentMomentum + (momentum / 2); // Transfer half momentum
                
                // OCEAN PROTECTION: Limit momentum in ocean areas
                int maxMomentum = isInOcean ? 50 : 300; // Lower cap for ocean
                
                return Math.min(jumpMomentum, maxMomentum);
            });
            
            // Mark jump target as processed
            String processedKey = "jumped_" + targetKey;
            highPriorityWaterCache.put(processedKey, System.currentTimeMillis());
        }
    }
    
    // Calculate jump targets based on momentum and position
    private static BlockPos[] calculateJumpTargets(BlockPos sourcePos, int jumpDistance) {
        java.util.List<BlockPos> targets = new java.util.ArrayList<>();
        
        // OCEAN PROTECTION: Limit jump distance in ocean areas
        boolean isInOcean = isInInfiniteOcean(sourcePos);
        int maxJumpDistance = isInOcean ? Math.min(jumpDistance, 3) : jumpDistance;
        
        // Prefer forward (horizontal) movement
        // Check for nearby water to determine flow direction
        BlockPos flowDirection = determineFlowDirection(sourcePos);
        
        if (flowDirection != null) {
            // Jump in flow direction
            targets.add(sourcePos.offset(flowDirection.getX() * maxJumpDistance, 
                                       flowDirection.getY() * maxJumpDistance, 
                                       flowDirection.getZ() * maxJumpDistance));
        } else {
            // Default horizontal directions
            targets.add(sourcePos.north(maxJumpDistance));
            targets.add(sourcePos.south(maxJumpDistance));
            targets.add(sourcePos.east(maxJumpDistance));
            targets.add(sourcePos.west(maxJumpDistance));
        }
        
        // Add downward jump for gravity assist (limited in ocean)
        if (sourcePos.getY() > 10 && !isInOcean) {
            targets.add(sourcePos.below(Math.min(maxJumpDistance / 2, 3)));
        }
        
        return targets.toArray(new BlockPos[0]);
    }
    
    // Determine flow direction based on nearby water
    private static BlockPos determineFlowDirection(BlockPos centerPos) {
        int[] directionCounts = new int[4]; // N, S, E, W
        BlockPos[] directions = {
            centerPos.north(1), centerPos.south(1), 
            centerPos.east(1), centerPos.west(1)
        };
        
        for (int i = 0; i < directions.length; i++) {
            String key = directions[i].getX() + "," + directions[i].getY() + "," + directions[i].getZ();
            if (momentumCache.containsKey(key)) {
                directionCounts[i] = momentumCache.get(key);
            }
        }
        
        // Find direction with most momentum
        int maxIndex = 0;
        int maxCount = directionCounts[0];
        for (int i = 1; i < directionCounts.length; i++) {
            if (directionCounts[i] > maxCount) {
                maxCount = directionCounts[i];
                maxIndex = i;
            }
        }
        
        // Return direction if there's significant momentum
        if (maxCount >= 10) {
            switch (maxIndex) {
                case 0: return new BlockPos(0, 0, -1); // North
                case 1: return new BlockPos(0, 0, 1);  // South
                case 2: return new BlockPos(1, 0, 0);  // East
                case 3: return new BlockPos(-1, 0, 0); // West
            }
        }
        
        return null; // No clear direction
    }
    
    // Apply multiplication to nearby fluids for chain acceleration
    private static void applyNearbyFluidMultiplication(BlockPos centerPos, int baseMultiplier) {
        // Multiply nearby fluids for faster river formation
        for (int i = -3; i <= 3; i++) { // Use single loop variable
            for (int j = -3; j <= 3; j++) {
                for (int k = -2; k <= 2; k++) {
                    if (i == 0 && k == 0 && j == 0) continue;
                    
                    final int dx = i; // Make final for lambda
                    final int dy = k; // Make final for lambda
                    final int dz = j; // Make final for lambda
                    
                    BlockPos nearbyPos = centerPos.offset(dx, dy, dz);
                    String nearbyKey = nearbyPos.getX() + "," + nearbyPos.getY() + "," + nearbyPos.getZ();
                    
                    // MULTIPLICATION POINT 11: Enhanced nearby multiplication
                    momentumCache.compute(nearbyKey, (key, value) -> {
                        int currentMomentum = value == null ? 1 : value;
                        // Distance-based multiplier
                        int distance = Math.max(Math.abs(dx), Math.max(Math.abs(dy), Math.abs(dz)));
                        int distanceMultiplier = Math.max(2, baseMultiplier - distance);
                        
                        // MULTIPLICATION POINT 15: DAM BREAK CHAIN REACTION
                        // Apply extra multiplication for dam break scenarios
                        int nearbyWaterCount = countNearbyWaterBlocks(centerPos);
                        if (nearbyWaterCount >= 8) {
                            distanceMultiplier *= 3; // Triple for dam break chain reactions
                        }
                        
                        // MULTIPLICATION POINT 16: FORWARD DIRECTION BOOST
                        // Apply extra boost for horizontal movement (forward momentum)
                        if (dy == 0 && (Math.abs(dx) <= 2 || Math.abs(dz) <= 2)) {
                            // Horizontal movement gets extra boost
                            distanceMultiplier += 2;
                        }
                        
                        // MULTIPLICATION POINT 17: CENTER PRESSURE MULTIPLICATION
                        // Apply massive multiplier for low center of fluid volumes
                        if (isInFluidCenter(nearbyPos, centerPos)) {
                            distanceMultiplier *= 5; // 5x for fluid center
                            distanceMultiplier += 10; // +10 for low center pressure
                        }
                        
                        // MULTIPLICATION POINT 18: DEPTH-BASED PRESSURE
                        // Lower positions get more pressure (center of fluid volume)
                        if (nearbyPos.getY() < centerPos.getY()) {
                            int depthDifference = centerPos.getY() - nearbyPos.getY();
                            distanceMultiplier += depthDifference * 2; // 2x per block depth
                        }
                        
                        // MULTIPLICATION POINT 12: Distance-based exponential multiplication
                        int newMomentum = currentMomentum * distanceMultiplier;
                        return Math.min(newMomentum, 500); // Higher cap for center pressure
                    });
                    
                    // Mark nearby as processed
                    String processedKey = "processed_" + nearbyKey;
                    highPriorityWaterCache.put(processedKey, System.currentTimeMillis());
                }
            }
        }
    }
    
    // Check if position is in the center of a fluid volume
    private static boolean isInFluidCenter(BlockPos checkPos, BlockPos centerPos) {
        // Check if this position is in the low center of fluid
        // Lower Y positions = center of fluid volume
        if (checkPos.getY() < centerPos.getY()) {
            // Check if surrounded by water on all sides (center of volume)
            int waterSurroundings = 0;
            for (int dx = -1; dx <= 1; dx++) {
                for (int dz = -1; dz <= 1; dz++) {
                    if (dx == 0 && dz == 0) continue;
                    
                    BlockPos surroundPos = checkPos.offset(dx, 0, dz);
                    String surroundKey = surroundPos.getX() + "," + surroundPos.getY() + "," + surroundPos.getZ();
                    
                    // Check if surrounded by water
                    if (momentumCache.containsKey(surroundKey) || 
                        highPriorityWaterCache.containsKey("processed_" + surroundKey)) {
                        waterSurroundings++;
                    }
                }
            }
            
            // Center if surrounded by 6+ water blocks
            return waterSurroundings >= 6;
        }
        
        return false;
    }
    
    // Calculate acceleration multiplier based on fluid conditions
    private static int calculateAccelerationMultiplier(BlockPos pos, String fluidType) {
        int multiplier = 1;
        
        // SURFACE FLUIDS: Accelerate visible fluids
        if (pos.getY() > 60) {
            multiplier += 3; // Surface fluids get +3
        } else if (pos.getY() > 50) {
            multiplier += 2; // Near-surface fluids get +2
        }
        
        // UNDERGROUND FLUIDS: Accelerate out-of-sight fluids
        if (pos.getY() < 30) {
            multiplier += 5; // Underground fluids get +5 (fastest)
        }
        
        // RIVER FLOW: Accelerate horizontal movement
        // Check if near other fluids (simulate river flow)
        for (int dx = -1; dx <= 1; dx++) {
            for (int dz = -1; dz <= 1; dz++) {
                if (dx == 0 && dz == 0) continue;
                BlockPos nearbyPos = pos.offset(dx, 0, dz);
                String nearbyKey = nearbyPos.getX() + "," + nearbyPos.getY() + "," + nearbyPos.getZ();
                if (momentumCache.containsKey(nearbyKey)) {
                    multiplier += 1; // Bonus for being near other moving fluids
                    break;
                }
            }
        }
        
        // GRAVITY ASSIST: Accelerate downward movement
        // Check if below is air or lower position
        BlockPos belowPos = pos.below();
        if (belowPos.getY() < pos.getY()) {
            multiplier += 1; // Gravity assist
        }
        
        // MULTIPLICATION POINT 13: DAM BREAK FORWARD MOMENTUM
        // Check for high-volume water scenarios (like dam breaks)
        int nearbyWaterCount = countNearbyWaterBlocks(pos);
        if (nearbyWaterCount >= 8) { // 8+ nearby water blocks = dam break scenario
            multiplier += nearbyWaterCount; // Add water count as multiplier
            multiplier *= 2; // Double for high-volume scenarios
        }
        
        // MULTIPLICATION POINT 14: FORWARD MOMENTUM BOOST
        // Apply extra multiplier for forward movement when there's high volume
        if (nearbyWaterCount >= 5) {
            multiplier += 3; // Extra forward momentum bonus
        }
        
        // MULTIPLICATION POINT 4: Apply exponential multiplier for extreme conditions
        if (multiplier >= 6) {
            multiplier = multiplier * 2; // Double for extreme conditions
        }
        
        return Math.min(multiplier, 20); // Increased cap for dam break scenarios
    }
    
    // Count nearby water blocks for dam break detection
    private static int countNearbyWaterBlocks(BlockPos centerPos) {
        int waterCount = 0;
        
        // Check 5×5×3 area for water blocks
        for (int dx = -2; dx <= 2; dx++) {
            for (int dz = -2; dz <= 2; dz++) {
                for (int dy = -1; dy <= 2; dy++) {
                    if (dx == 0 && dy == 0 && dz == 0) continue;
                    
                    BlockPos checkPos = centerPos.offset(dx, dy, dz);
                    String checkKey = checkPos.getX() + "," + checkPos.getY() + "," + checkPos.getZ();
                    
                    // Count if this position has momentum (indicates water)
                    if (momentumCache.containsKey(checkKey)) {
                        waterCount++;
                    }
                    
                    // Also check if it's marked as processed
                    String processedKey = "processed_" + checkKey;
                    if (highPriorityWaterCache.containsKey(processedKey)) {
                        waterCount++;
                    }
                }
            }
        }
        
        return waterCount;
    }
    
    // Check if block is fluid-related
    private static boolean isFluidRelatedBlock(BlockState state) {
        return !state.getFluidState().isEmpty();
    }
    
    // SERVER TICK EVENT HANDLER - Setup reflection hooks and cleanup
    @SubscribeEvent
    public static void onServerTick(TickEvent event) {
        if (event instanceof TickEvent.ServerTickEvent) {
            TickEvent.ServerTickEvent serverEvent = (TickEvent.ServerTickEvent) event;
            // Use equals() method for Phase comparison
            if (serverEvent.getPhase().equals(net.minecraftforge.event.TickEvent.Phase.END)) {
                tickCount.incrementAndGet();
                totalFluidEvents.set(0);
                skippedFluidEvents.set(0);
                
                // Initialize reflection hooks on first tick
                if (tickCount.get() == 1) {
                    boolean hookSuccess = initializeHookingSystem();
                    if (hookSuccess) {
                        System.out.println("[FlowingFluidsFixes] Consolidated hooking system initialized!");
                    }
                }
                
                // ACTIVE MONITORING: Apply hooking every tick (no new events)
                if (isHookActive) {
                    processFluidOperations();
                }
                
                // MULTIPLICATION POINT 5: Apply periodic momentum multiplication
                if (tickCount.get() % 20 == 0) { // Every 20 ticks
                    applyPeriodicMomentumMultiplication();
                }
                
                // Cleanup old cache entries periodically
                if (tickCount.get() % 1000 == 0) {
6                    manageCaches();
                }
            }
        }
    }
    
    // Apply periodic momentum multiplication for sustained acceleration
    private static void applyPeriodicMomentumMultiplication() {
        // Only multiply during good performance
        if (getMSPT() > 8.0) return;
        
        // Multiply all existing momentum values
        momentumCache.replaceAll((key, value) -> {
            if (value != null && value > 1) {
                // MULTIPLICATION POINT 6: Periodic exponential growth
                int multipliedMomentum = value * 2; // Double all momentum
                
                // MULTIPLICATION POINT 20: CENTER-FOCUSED PERIODIC BOOST
                // Apply extra boost for center positions during periodic multiplication
                String[] parts = key.split(",");
                if (parts.length == 3) {
                    try {
                        int x = Integer.parseInt(parts[0]);
                        int y = Integer.parseInt(parts[1]);
                        int z = Integer.parseInt(parts[2]);
                        BlockPos pos = new BlockPos(x, y, z);
                        
                        if (isInFluidCenter(pos, pos)) {
                            multipliedMomentum *= 2; // Double again for center positions
                            multipliedMomentum += 25; // +25 for center pressure
                        }
                    }
                    return multipliedMomentum;
                });
